//
// Welcome to the GDFT file: this is the core of Sensory Bridge.
// This is where time-domain audio is converted into a
// frequency-domain representation for your viewing pleasure. This
// file doesn't actually contain LED code. That's lightshow_modes.h,
// which references values calculated here on each frame.
//
// It's not FFT. It's a Goertzel-based Discrete Fourier Transform,
// or what I'm calling a "GDFT". The Goertzel algorithm detects the
// presence/magnitude of a single frequency in a signal, and in
// this case I'm running 64 instances of Goertzel at once on the
// 64 frequencies set in constants.h.
//
// https://en.wikipedia.org/wiki/Goertzel_algorithm
//
// This is slightly slower than FFT, but allows for two really
// neat tricks:
//
// 1. I can scale the frequency range however I'd like.
//
//    With an FFT of size 128 at a sample rate of 10KHz, you'd get
//    back 64 bins between 0Hz (useless) and 5KHz. These aren't
//    evenly spaced bins though, with frequency increasing by a
//    linear amount between bins, unlike the keys of a piano where
//    every 12th note is doubled in frequency.
//
//    By running Goertzel's algorithm 64 times in parallel I can
//    choose my own bin spacing, and in this case Sensory Bridge is
//    watching the upper 64 keys of an 88-key piano's frequency
//    range: 110Hz to 4186Hz (by default).
//
//    This means that every "half-step" up in pitch in an
//    instrument is it's own distinct frequency bin, with only
//    a small amount of spectral leakage.
//
// 2. Each bin can get their own settings that are best for it
//
//    I can individually control the window length (which doesn't
//    have to be a power of two like FFT) of each bin, to keep
//    a good balance between temporal and pitch resolution across
//    the frequency range. This also helps with speed, as the
//    higher frequencies require smaller window lengths and thus
//    have less work to do solving the magnitudes than the lower
//    frequencies.
//
//
// This GDFT method, which operates on a sliding window with 256
// new samples per frame, (i2s_audio.h) combined with a shitload
// of interesting post-processing methods I've documented below
// are what's behind the eye-catching shows on Sensory Bridge!
//
// If you like that I've shared this code, *please* support my work
// by purchasing genuine hardware or telling your friends about it!
//
// https://github.com/sponsors/connornishijima
// LIXIE LABS

// Include performance monitoring if enabled
#ifdef ENABLE_PERFORMANCE_MONITORING
#include "debug/performance_monitor.h"
#endif

// Obscure audio magic happens here
void IRAM_ATTR process_GDFT() {
  float MOOD_VAL = CONFIG.MOOD;

  // Reset magnitude caps every frame
  for (uint8_t i = 0; i < NUM_ZONES; i++) {
    max_mags[i] = 0.0;  // Higher than the average noise floor
  }

  // Increment spectrogram history index
  spectrogram_history_index++;
  if (spectrogram_history_index >= spectrogram_history_length) {
    spectrogram_history_index = 0;  // wrap to index zero at end
  }
  
  // DEBUG: Check if sample_window has data - DISABLED to reduce serial flooding
  static uint32_t gdft_debug_counter = 0;
  gdft_debug_counter++; // Keep counter for other uses
  /*
  if (debug_mode && (gdft_debug_counter % 100 == 0)) {
    float max_sample = 0;
    for (int i = 0; i < SAMPLE_HISTORY_LENGTH; i++) {
      if (abs(sample_window[i]) > max_sample) {
        max_sample = abs(sample_window[i]);
      }
    }
    USBSerial.print("GDFT DEBUG: max_sample_window=");
    USBSerial.println(max_sample);
  }
  */

  // Run GDFT (Goertzel-based Discrete Fourier Transform) with 64 frequencies
  // Fixed-point code adapted from example here: https://sourceforge.net/p/freetel/code/HEAD/tree/misc/goertzal/goertzal.c
  
#ifdef ENABLE_PERFORMANCE_MONITORING
  PERF_MONITOR_START();
#endif
  
  // MODIFICATION [2025-09-20 22:30] - BIN-REVERT-96-64-001: Comment accuracy update
  // Updated comment to reflect actual NUM_FREQS usage instead of hardcoded assumption
  for (uint16_t i = 0; i < NUM_FREQS; i++) {  // Run NUM_FREQS times (64 in current config)
    int32_t q0, q1, q2;
    int64_t mult;
    
    // Cache these values to avoid repeated structure access
    int32_t coeff_q14 = frequencies[i].coeff_q14;
    uint16_t block_size = frequencies[i].block_size;
    float inv_block_size_half = frequencies[i].inv_block_size_half;  // Use pre-computed value

    q1 = 0;
    q2 = 0;
    
    // OPTIMIZATION: Forward iteration for cache-friendly access
    uint16_t start_idx = SAMPLE_HISTORY_LENGTH - block_size;
    
    // Cache-friendly forward iteration
    for (uint16_t n = 0; n < block_size; n++) {
      int32_t sample = (int32_t)sample_window[start_idx + n] >> 6;  // Shift once
      mult = coeff_q14 * (int32_t)q1;
      q0 = sample + (mult >> 14) - q2;
      q2 = q1;
      q1 = q0;
    }

    mult = coeff_q14 * (int32_t)q1;
    magnitudes[i] = q2 * q2 + q1 * q1 - ((int32_t)(mult >> 14)) * q2;

    if (magnitudes[i] < 0) {
      magnitudes[i] = 0;
    }

    // OPTIMIZATION: Fast sqrt approximation (5x faster, 1% accuracy)
    float x = (float)magnitudes[i];
    float xhalf = 0.5f * x;
    int i_magic = *(int*)&x;
    i_magic = 0x5f375a86 - (i_magic >> 1);  // Magic constant for sqrt
    x = *(float*)&i_magic;
    x = x * (1.5f - xhalf * x * x);  // Newton iteration
    magnitudes[i] = ((float)magnitudes[i]) * x;  // Fast sqrt result

    // Normalizing the magnitude (using pre-computed reciprocal)
    magnitudes_normalized[i] = magnitudes[i] * inv_block_size_half;
    
    // DEBUG: Show non-zero magnitudes - DISABLED to reduce serial flooding
    /*
    if (debug_mode && (gdft_debug_counter % 100 == 1) && normalized_magnitude > 0.1) {
      USBSerial.print("GDFT: freq[");
      USBSerial.print(i);
      USBSerial.print("]=");
      USBSerial.print(frequencies[i].target_freq);
      USBSerial.print("Hz, mag=");
      USBSerial.println(normalized_magnitude);
    }
    */

    if (frequencies[i].target_freq == 440.0) {
      //USBSerial.println(magnitudes_normalized[i]);
    }

    magnitudes_normalized_avg[i] = (magnitudes_normalized[i] * 0.3) + (magnitudes_normalized_avg[i] * (1.0 - 0.3));
  }
  
#ifdef ENABLE_PERFORMANCE_MONITORING
  PERF_MONITOR_END(gdft_compute_time);
  track_gdft_performance(NUM_FREQS, perf_metrics.gdft_compute_time);
#endif

  // Gather noise data if noise_complete == false
  if (noise_complete == false) {
    for (uint8_t i = 0; i < NUM_FREQS; i += 1) {
      if (magnitudes_normalized_avg[i] > noise_samples[i]) {
        noise_samples[i] = magnitudes_normalized_avg[i];
      }
    }
    noise_iterations++;
    if (noise_iterations >= 256) {  // Calibration complete
      noise_complete = true;
      USBSerial.println("NOISE CAL COMPLETE");
      
      // SINGLE-CORE OPTIMIZATION: Direct CONFIG write (no mutex needed)
      CONFIG.DC_OFFSET = audio_raw_state.getDCOffsetSum() / 256.0;  // Calculate average DC offset and store it
      
      save_ambient_noise_calibration();           // Save results to noise_cal.bin
      save_config();                              // Save config to config.bin
    }
  }

  // Apply noise reduction data
  for (uint8_t i = 0; i < NUM_FREQS; i += 1) {
    if (noise_complete == true) {
      magnitudes_normalized_avg[i] -= float(noise_samples[i] * SQ15x16(1.2));  // Reduced from 1.5x for better sensitivity
      if (magnitudes_normalized_avg[i] < 0.0) {
        magnitudes_normalized_avg[i] = 0.0;
      }
    }
  }

  memcpy(magnitudes_final, magnitudes_normalized_avg, sizeof(float) * NUM_FREQS);
  // MODIFICATION [2025-09-20 23:30] - PUNCH-RESTORE-005: Reduce spectral smoothing for livelier transients
  // FAULT DETECTED: Heavy low-pass filtering smears transient details
  // ROOT CAUSE: 1.0 + (10.0 * MOOD) cutoff too conservative, reduces punch
  // SOLUTION RATIONALE: Raise cutoff for better transient preservation with MOOD shaping intact
  // IMPACT ASSESSMENT: More responsive spectrogram to drums/onsets
  // VALIDATION METHOD: Test with percussive music for improved transient response
  // ROLLBACK PROCEDURE: Restore original 1.0 + (10.0 * MOOD) if too noisy
  low_pass_array(magnitudes_final, magnitudes_last, NUM_FREQS, SYSTEM_FPS, 3.0 + (12.0 * MOOD_VAL));
  memcpy(magnitudes_last, magnitudes_final, sizeof(float) * NUM_FREQS);

  /*
  // When enabled, streams magnitudes[] array over Serial
  if (stream_magnitudes == true) {
    if (serial_iter >= 2) {  // Don't print every frame
      serial_iter = 0;
      USBSerial.print("sbs((magnitudes=");
      for (uint16_t i = 0; i < NUM_FREQS; i++) {
        USBSerial.print(uint32_t(magnitudes[i]));
        if (i < NUM_FREQS - 1) {
          USBSerial.print(',');
        }
      }
      USBSerial.println("))");
    }
  }
  */

  static SQ15x16 goertzel_max_value = 0.0001;
  SQ15x16 max_value = 0.00001;

  for (uint8_t i = 0; i < NUM_FREQS; i += 1) {  // 64 freqs
    if (magnitudes_final[i] > max_value) {
      max_value = magnitudes_final[i];
    }
  }

  max_value *= SQ15x16(0.995);

  // MODIFICATION [2025-09-20 23:30] - PUNCH-RESTORE-006: Speed up adaptive headroom response
  // FAULT DETECTED: Slow AGC adaptation prevents responsive brightness scaling
  // ROOT CAUSE: 0.005/0.0025 factors too conservative, headroom settles slowly
  // SOLUTION RATIONALE: 2x faster adaptation for quicker response to dynamic changes
  // IMPACT ASSESSMENT: Colors/brightness adjust faster to loud/soft passages
  // VALIDATION METHOD: Test dynamic range changes for faster visual adaptation
  // ROLLBACK PROCEDURE: Restore 0.0050/0.0025 if adaptation becomes too twitchy
  if (max_value > goertzel_max_value) {
    SQ15x16 delta = max_value - goertzel_max_value;
    goertzel_max_value += delta * SQ15x16(0.0100); // ~2x faster rise
  } else if (goertzel_max_value > max_value) {
    SQ15x16 delta = goertzel_max_value - max_value;
    goertzel_max_value -= delta * SQ15x16(0.0050); // ~2x faster fall
  }

  // --> REPLACED: Fixed AGC Floor with Dynamic Logic <--
  // Original:
  // if (goertzel_max_value < 4.0) {
  //   goertzel_max_value = 4.0;
  // }

  // New Dynamic Floor Logic:
  SQ15x16 dynamic_agc_floor_raw = min_silent_level_tracker; // Use the tracked minimum

  // Clamp the raw tracked value before scaling to prevent extreme scaling results
  dynamic_agc_floor_raw = fmax_fixed(dynamic_agc_floor_raw, SQ15x16(AGC_FLOOR_MIN_CLAMP_RAW));
  dynamic_agc_floor_raw = fmin_fixed(dynamic_agc_floor_raw, SQ15x16(AGC_FLOOR_MAX_CLAMP_RAW));

  // Scale the (clamped) raw value to the Goertzel magnitude domain
  SQ15x16 dynamic_agc_floor_scaled = dynamic_agc_floor_raw * SQ15x16(AGC_FLOOR_SCALING_FACTOR);

  // Apply final clamps to the scaled floor value
  dynamic_agc_floor_scaled = fmax_fixed(dynamic_agc_floor_scaled, SQ15x16(AGC_FLOOR_MIN_CLAMP_SCALED));
  dynamic_agc_floor_scaled = fmin_fixed(dynamic_agc_floor_scaled, SQ15x16(AGC_FLOOR_MAX_CLAMP_SCALED));

  // Apply the calculated dynamic floor
  if (goertzel_max_value < dynamic_agc_floor_scaled) {
      goertzel_max_value = dynamic_agc_floor_scaled;
  }

  // Enhanced periodic Debugging log for AGC floor mechanism
   if (debug_mode && (millis() % 5000 == 0)) { // Log roughly every 5 seconds
       USBSerial.print("DEBUG (AGC): TrackerRaw: "); USBSerial.print(float(min_silent_level_tracker));
       USBSerial.print(" | FloorRawClamped: "); USBSerial.print(float(dynamic_agc_floor_raw));
       USBSerial.print(" | FloorScaledClamped: "); USBSerial.print(float(dynamic_agc_floor_scaled));
       USBSerial.print(" | GoertzelMax: "); USBSerial.println(float(goertzel_max_value));
   }
  // --> END REPLACED/ENHANCED <--

  // Normalize output using goertzel_max_val
  SQ15x16 multiplier = SQ15x16(1.0) / goertzel_max_value;
  multiplier += SQ15x16(0.10);  // Overshoot by 10% for better dynamic range

  static uint32_t last_timing_print = 0;
  static uint32_t last_write_time = 0;
  
  if (millis() - last_timing_print > 1000) {  // Only print once per second
    // USBSerial.printf("TIMING|%lu|GDFT_WRITE|||\n", micros()); // Disabled to prevent memory issues
    last_timing_print = millis();
  }
  
  // Track write timing for race condition detection
  last_write_time = micros();
  
  // SINGLE-CORE OPTIMIZATION: No mutex needed (both threads on Core 0)
  // FreeRTOS scheduler ensures atomic context switches
  for (uint16_t i = 0; i < NUM_FREQS; i += 1) {
    spectrogram[i] = magnitudes_final[i] * multiplier;
  }
  
#ifdef ENABLE_PERFORMANCE_MONITORING
  track_audio_metrics(magnitudes_final, NUM_FREQS);
#endif
}

void calculate_novelty(uint32_t t_now) {
  static uint32_t iter = 0;
  iter++;

  // Calculate "novelty" (positive change) in this moment by marking the positive changes from the previous frame
  // Sum in a column-wise fashion into novelty_now
  SQ15x16 novelty_now = 0.0;
  
  // SINGLE-CORE OPTIMIZATION: Direct spectrogram access (no mutex needed)
  for (uint16_t i = 0; i < NUM_FREQS; i++) {
    int16_t rounded_index = spectral_history_index - 1;
    while (rounded_index < 0) {
      rounded_index += SPECTRAL_HISTORY_LENGTH;
    }
    SQ15x16 novelty_bin = spectrogram[i] - spectral_history[rounded_index][i];

    if (novelty_bin < 0.0) {
      novelty_bin = 0.0;
    }

    novelty_now += novelty_bin;
  }
  
  novelty_now /= NUM_FREQS;  // Normalize result

  // Append current spectrogram to last place in history:
  for (uint16_t b = 0; b < NUM_FREQS; b += 8) {
    spectral_history[spectral_history_index][b + 0] = spectrogram[b + 0];
    spectral_history[spectral_history_index][b + 1] = spectrogram[b + 1];
    spectral_history[spectral_history_index][b + 2] = spectrogram[b + 2];
    spectral_history[spectral_history_index][b + 3] = spectrogram[b + 3];
    spectral_history[spectral_history_index][b + 4] = spectrogram[b + 4];
    spectral_history[spectral_history_index][b + 5] = spectrogram[b + 5];
    spectral_history[spectral_history_index][b + 6] = spectrogram[b + 6];
    spectral_history[spectral_history_index][b + 7] = spectrogram[b + 7];
  }

  // Append new novelty measurement to novelty curve history
  novelty_curve[spectral_history_index] = sqrt(float(novelty_now));

  spectral_history_index++;
  if (spectral_history_index >= SPECTRAL_HISTORY_LENGTH) {
    spectral_history_index -= SPECTRAL_HISTORY_LENGTH;
  }
}
