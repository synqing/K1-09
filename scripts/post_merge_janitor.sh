#!/usr/bin/env bash
# Post-merge janitor: closes linked issue, regenerates analysis, posts metrics summary.
set -Eeuo pipefail
IFS=$'\n\t'

if [[ $# -lt 1 ]]; then
  echo "Usage: $0 <pr-number>" >&2
  exit 2
fi

need() { command -v "$1" >/dev/null 2>&1 || { echo "Missing $1" >&2; exit 1; }; }
need gh
need git
need jq
need python3

PR_NUMBER="$1"

PR_JSON="$(gh api "repos/{owner}/{repo}/pulls/${PR_NUMBER}")"
MERGED="$(jq -r '.merged' <<<"$PR_JSON")"
STATE="$(jq -r '.state' <<<"$PR_JSON")"
BASE_REF="$(jq -r '.base.ref' <<<"$PR_JSON")"
BASE_SHA="$(jq -r '.base.sha' <<<"$PR_JSON")"
MERGE_SHA="$(jq -r '.merge_commit_sha' <<<"$PR_JSON")"
BODY="$(jq -r '.body // ""' <<<"$PR_JSON")"

if [[ "$MERGED" != "true" ]]; then
  echo "PR #$PR_NUMBER is not merged (state=$STATE)." >&2
  exit 1
fi

REPO_SLUG="$(gh repo view --json nameWithOwner -q .nameWithOwner)"
echo "Repo: $REPO_SLUG"
echo "Base: $BASE_REF @ $BASE_SHA"
echo "Merge commit: $MERGE_SHA"

ISSUE_NUMBER="$(sed -n 's/.*[Cc]loses #\([0-9]\+\).*/\1/p' <<<"$BODY" | head -n1 || true)"
if [[ -n "$ISSUE_NUMBER" ]]; then
  ISSUE_STATE="$(gh issue view "$ISSUE_NUMBER" --json state -q .state || echo "UNKNOWN")"
  if [[ "$ISSUE_STATE" == "OPEN" ]]; then
    echo "Closing linked issue #$ISSUE_NUMBER"
    gh issue close "$ISSUE_NUMBER" -c "Closed by post-merge janitor for PR #$PR_NUMBER."
  else
    echo "Linked issue #$ISSUE_NUMBER already $ISSUE_STATE"
  fi
else
  echo "No linked issue detected."
fi

METRICS_SCRIPT="$(realpath scripts/metrics_report.py 2>/dev/null || true)"
if [[ -z "$METRICS_SCRIPT" || ! -f "$METRICS_SCRIPT" ]]; then
  echo "metrics_report.py not found; ensure the script exists before running janitor." >&2
  exit 1
fi

WORKTREE=".janitor_before"
if [[ -d "$WORKTREE" ]]; then
  git worktree remove -f "$WORKTREE"
fi
git worktree add -f "$WORKTREE" "$BASE_SHA" >/dev/null 2>&1

pushd "$WORKTREE" >/dev/null
BEFORE_TMP="$(mktemp)"
if ! python3 "$METRICS_SCRIPT" --write-analysis >"$BEFORE_TMP" 2>/dev/null; then
  if ! python3 "$METRICS_SCRIPT" >"$BEFORE_TMP" 2>/dev/null; then
    printf '{}' >"$BEFORE_TMP"
  fi
fi
B_HEADERS=$(jq -r '.headers_count // 0' "$BEFORE_TMP" 2>/dev/null || echo 0)
B_SOURCES=$(jq -r '.sources_count // 0' "$BEFORE_TMP" 2>/dev/null || echo 0)
B_EDGES=$(jq -r '.edges_count // 0' "$BEFORE_TMP" 2>/dev/null || echo 0)
B_CYCLES=$(jq -r '.cycles_count // 0' "$BEFORE_TMP" 2>/dev/null || echo 0)
rm -f "$BEFORE_TMP"
popd >/dev/null

git fetch origin "$BASE_REF" --quiet
git checkout "$BASE_REF"
git pull --ff-only

AFTER_TMP="$(mktemp)"
if ! python3 "$METRICS_SCRIPT" --write-analysis >"$AFTER_TMP" 2>/dev/null; then
  if ! python3 "$METRICS_SCRIPT" >"$AFTER_TMP" 2>/dev/null; then
    printf '{}' >"$AFTER_TMP"
  fi
fi
MAIN_SHA="$(git rev-parse --short HEAD)"
A_HEADERS=$(jq -r '.headers_count // 0' "$AFTER_TMP" 2>/dev/null || echo 0)
A_SOURCES=$(jq -r '.sources_count // 0' "$AFTER_TMP" 2>/dev/null || echo 0)
A_EDGES=$(jq -r '.edges_count // 0' "$AFTER_TMP" 2>/dev/null || echo 0)
A_CYCLES=$(jq -r '.cycles_count // 0' "$AFTER_TMP" 2>/dev/null || echo 0)
rm -f "$AFTER_TMP"

git worktree remove -f "$WORKTREE" >/dev/null 2>&1 || true

COMMENT="**Post-merge janitor** ✅

- Regenerated \`analysis/\` on **${BASE_REF}@${MAIN_SHA}**
- Linked issue: ${ISSUE_NUMBER:+#${ISSUE_NUMBER} (closed)}${ISSUE_NUMBER:="None"}

**Before → After metrics**
- Headers: \`${B_HEADERS}\` → \`${A_HEADERS}\`
- Sources: \`${B_SOURCES}\` → \`${A_SOURCES}\`
- Dep edges: \`${B_EDGES}\` → \`${A_EDGES}\`
- Dep cycles: \`${B_CYCLES}\` → \`${A_CYCLES}\`

_Generated by \`scripts/post_merge_janitor.sh ${PR_NUMBER}\`._"

gh pr comment "$PR_NUMBER" --body "$COMMENT"
